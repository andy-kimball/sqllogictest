<h1>About Sqllogictest</h1>

Sqllogictest is a program designed to test the
[http://www.sqlite.org/ | SQLite] database engine to verify that it computes
the same results as other SQL database engines such as MySQL, PostgreSQL,
Firebird, MS-SQL, Informix, DB2, Oracle, and so forth.  Sqllogictest is
concerned only with correct results.  No attention is paid to performance,
optimal use of indices, disk and memory usage, transactional behavior,
or concurrancy and locking issues.  
The sqllogictest program seeks to answer just one question:

<blockquote><i>
Does the database engine compute the correct answer to queries.
</i></blockquote>

The sqllogictest program is designed to validate SQLite.  But it is really
database engine neutral and can just as easily be used to validate the SQL
logic of any other SQL database engine by comparing computed result against
its peers.

<h2>Operation</h2>

The sqllogictest program is driven by scripts containing SQL statements
and queries and, sometimes, query results.  A script that omits the
results is called a "prototype script".  A script that includes results
is a "test script".

The sqllogictest program operates in two modes:  script completion mode
and script validation mode.  In script completion mode, the sqllogictest
program reads a prototype script and runs the statements and queries against
a reference database engine.  The output is a test script that is a copy
of the prototype script with result inserted.  In validation mode,
the sqllogictest program reads a test script and runs the statements and
queries contained therein against a database engine under test.  The results
received back from the database engine are compared against the results
in the test script to validate the output of the database engine.

For example, to verify that SQLite gets the same answer as MySQL on
a particular set of queries, one might execute commands as follows.
First complete the prototype script using MySQL as the reference database
engine:

<blockquote><pre>
sqllogictest -engine MySQL prototype.txt >full.txt
</pre></blockquote>

Then verify the results using SQLite:

<blockquote><pre>
sqllogictest -verify -engine SQLite full.txt
</pre></blockquote>

The second command will display any discrepencies between the output
generated by SQLite and the reference data that was generated by MySQL
in the first command.

Another approach to validation is to run the competion step separately
for each database engine and save the output in separate test scripts.
The compare the two test scripts using a file comparison utility.
For example:

<blockquote><pre>
sqllogictest -engine MySQL prototype.txt >full-1.txt
sqllogictest -engine SQLite prototype.txt >full-2.txt
diff full-1.txt full-2.txt
</pre></blockquote>

Note that in completion mode, the sqllogictest program will ignore any
result value contained in its input script.  Or, in other words, it is
safe to pass a full test script into sqllogictest running in completion
mode.  So the previous test could have been run this way:

<blockquote><pre>
sqllogictest -engine MySQL prototype.txt >full-1.txt
sqllogictest -engine SQLite full-1.txt >full-2.txt
diff full-1.txt full-2.txt
</pre></blockquote>

The long-term vision of the sqllogictest project is to amass a huge 
collection of prototype scripts.  Many of the prototype scripts will
be very large, being automatically generated by some dynamic language
like Tcl, or Perl.  Prototype scripts will try queries using all kinds
of combinations on constraints and column orders, in order to exercize
as many paths through the logic of the database engine as possible.

<h2>Script Format</h2>

Scripts are line-oriented ASCII text files.  
No provision is made for Unicode; the purpose
of sqllogictest is to test the query and join logic of the database engine, not
its support for localization and internationalization.

Scripts consist of zero or more records.  A record represents either a
single statement or query.  Each record
is separated from its neighbors by one or more blank line.  Records
are evaluated in order, starting from the beginning of the
script and working toward the end.

Lines of the script that being with the sharp character ("#", ASCCI code 35)
are comment lines and are ignored.  Comment lines are not considered blank
lines and cannot be used to separate records.  Comments
typically occur at the beginning of a record, but they are
allowed to occur in the middle of a record.  Comments
that occurs in the middle of an SQL statement are stripped from the
statement prior to the statement being sent to the database engine for
evaluation.  Comments are logically removed from the script by a preprocessor.
Hence, in the sequal, when we speak of the "first line of a record" we
really mean the "first non-comment line of a record".

Each record is either a statement or a query.  A statement is an SQL
command that is to be evaluated but from which we do not expect to get
results (other than success or failure).  A statement might be a
CREATE TABLE or an INSERT or an UPDATE or a DROP INDEX.  A query is an
SQL command from which we expect to receive results.  The result set
might be empty.

A statement record begins with one of the following two lines:

<blockquote><pre>
statement ok
statement error
</pre></blockquote>

The SQL command to be evaluated is found on the second and all subsequent
liens of the record.  Only a single SQL command is allowed per statement.
The SQL should not have a semicolon or other terminator at the end;  any
required terminators will be added by the database engine interface module.

The SQL command is expected to succeed if the "ok" argument is used and is
expected to fail if the "error" argument is used.  Most statements are
expected to succeed.  But some statements can deliberately fail.  For
example, an INSERT statement that violates a UNIQUE or CHECK or NOT NULL
constraint might fail.  

A query record begins with a line of the following form:

<blockquote>
<tt>query</tt> <i>&lt;type-string&gt; &lt;sort-mode&gt;</i>
</blockquote>

The SQL for the query is found on second an subsequent lines of the 
record up to first line of the form "----" or until the end of the
record.  Lines following the "----" are expected results of the query,
one value per line.  If the "----" and/or the results are omitted, then
the query is expected to return an empty set.  The "----" and results
are also omitted from prototype scripts and are always ignored when
the sqllogictest program is operating in completion mode.  Another way
of thinking about completion mode is that it copies the script from
input to output, replacing all "----" lines and subsequent result values
with the actual results from running the query.

The &lt;type-string&gt; argument to the query statement is a short string
that specifies the number of result columns and the expected datatype
of each result column.  There is one character in the &lt;type-string&gt;
for each result column.  The characters is "S" for a string result,
"I" for an integer result, and "R" for a floating-point result.

The &lt;sort-mode&gt; argument is optional.  If included, it must be
one of "nosort", "rowsort", or "valuesort".  The default is "nosort".
In nosort mode, the results appear in esactly the order in which they
were received from the database engine.  The nosort mode should only
be used on queries that have an ORDER BY clause or which only have a
single row of result, since otherwise the order of results is undefined
and might vary from one database engine to another.  The "rowsort" mode
gathers all output from the database engine then sorts it by rows on
the client side.  Sort comparisons use memcmp() on the rendered ASCII
text representation of the values.  Hence, "9" sorts after "10", not before.
The "valuesort" mode works like rowsort except that it does not honor
row groupings.  Each individual result value is sorted on its own.

In the results section, integer values are rendered as if by
printf("%d").  Floating point values are rendered as if by
printf("%.3f").  NULL values are rendered as "<NULL>".  Empty
strings are rendered as "<EMPTY-STRING>".  Within non-empty strings,
all control characters and unprintable characters are rendered as "@".
